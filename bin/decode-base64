#!/usr/bin/env bash

main() {
  local tee=n
  local -i size=1048576

  local opt OPTIND OPTARG

  while getopts ":hts:" opt; do
    case $opt in
    h)
      cat <<'EOF'
USAGE: decode-base64 [-h] [-t] [-s BUF_SIZE] [FILE]

Read a base64 encoded blob from stdin, decode it and write the output to FILE.

If FILE is not provided, echo output to stdout. To both write to FILE and echo to
stdout, use the -t option.

If there is no piping or redirection to stdin, prompt for input.

OPTIONS:
    -h                Show this help message
    -t                Echo decoded JSON to stdout
    -s BUF_SIZE       Buffer size in MB for holding the input blob.
                      Must be an integer. Defaults to 1. Only necessary for
                      very large input blob in interactive mode.
EOF

      return 0
      ;;
    t)
      tee=y
      ;;
    s)
      size=$((size * OPTARG))
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2

      return 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2

      return 1
      ;;
    esac
  done

  shift $((OPTIND - 1))

  if (($# > 1)); then
    echo "Expects at most one positional argument, but $# was given."

    return 1
  fi

  local blob input

  if [[ -t 0 ]]; then
    read -r -n "$size" -p "Paste in the blob: " blob
    input="<<<'$blob'"
  else
    input=" <&0"
  fi

  # $blob is single-quoted in $input, so only $1 below is subject to
  # command injection. Since this is for own use, choose the eval
  # solution instead of writing more conditional code.
  local command
  if (($# == 1)) && [[ $tee == "y" ]]; then
    command="base64 -d $input | jq '.' | tee $1"
  elif (($# == 1)); then
    command="base64 -d $input | jq '.' >$1"
  else
    command="base64 -d $input | jq '.'"
  fi

  eval "$command"
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main "$@"
fi
